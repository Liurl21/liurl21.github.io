<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liurl21&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liurl21.github.io/"/>
  <updated>2017-01-09T05:39:50.000Z</updated>
  <id>https://liurl21.github.io/</id>
  
  <author>
    <name>Liurl21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rxjava 整理</title>
    <link href="https://liurl21.github.io/2017/01/09/Rxjava/"/>
    <id>https://liurl21.github.io/2017/01/09/Rxjava/</id>
    <published>2017-01-09T05:38:29.000Z</published>
    <updated>2017-01-09T05:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017年1月5日-下午3-07"><a href="#2017年1月5日-下午3-07" class="headerlink" title="2017年1月5日 下午3:07"></a>2017年1月5日 下午3:07</h3><p>未完成, 结合实践后继续完善。</p>
<h1 id="RxJava-整理"><a href="#RxJava-整理" class="headerlink" title="RxJava 整理"></a>RxJava 整理</h1><h2 id="RxJava-是什么"><a href="#RxJava-是什么" class="headerlink" title="RxJava 是什么"></a>RxJava 是什么</h2><p>“a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）</p>
<ul>
<li>拓展的观察者模式</li>
<li>异步数据流处理 (Rxjava 的核心)</li>
</ul>
<h3 id="RxJava-的优点"><a href="#RxJava-的优点" class="headerlink" title="RxJava 的优点"></a>RxJava 的优点</h3><p><strong>简洁</strong>, Android 创造的 AsyncTask 和 Handler，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，<strong>随着程序逻辑变得越来越复杂，它依然能够保持逻辑的简洁</strong>。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>RxJava 的异步实现, 是通过一种拓展的观察者模式来实现的。</p>
<h3 id="观察者模式-是什么"><a href="#观察者模式-是什么" class="headerlink" title="观察者模式 是什么"></a>观察者模式 是什么</h3><ul>
<li>Observable 发出事件</li>
<li>Subscriber 订阅事件</li>
</ul>
<h3 id="观察者模式的不足"><a href="#观察者模式的不足" class="headerlink" title="观察者模式的不足"></a>观察者模式的不足</h3><ul>
<li>不知道事件何时结束</li>
<li>缺少错误通知机制</li>
</ul>
<h3 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h3><p>RxJava 有四个基本概念: Observable(被观察者)、Observer(观察者)、subscribe(订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系, 从而 Observable 可以在需要的时候通知 Observer。</p>
<p>与传统的观察者模式不同, RxJava 的事件回调方法除了普通时间 onNext()(相当于 onClick()/onEvent()) 之外, 还定义了两个特殊的事件:</p>
<ul>
<li><p>onComplete 方法通知 Subscriber 事件结束, 事件队列完结。<br>  RxJava 不仅把每个事件单独处理, 还会把它们看做一个队列。RxJava 规定, 当不会再有新的 onNext() 发出时, 需要触发 onCompleted() 方法作为标志。        </p>
</li>
<li><p>onError 方法通知 Subscriber 出错, 事件队列异常。<br>  当事件处理过程中出现异常时, onError() 会被触发, 同时队列自动终止, 不允许再有事件发出。</p>
</li>
</ul>
<p>onCompleted() 和 onError() 二者是互斥的, 在一个事件序列中, 有且只有其中一个执行。</p>
<p>RxJava 的观察者模式大致如下:</p>
<p>Observable -&gt; onNext(param)/onCompleted()/onError(error) -&gt; Observer</p>
<h2 id="Rxjava-的基本实现"><a href="#Rxjava-的基本实现" class="headerlink" title="Rxjava 的基本实现"></a>Rxjava 的基本实现</h2><p>Rxjava 的基本实现主要有三点:</p>
<ul>
<li>创建 Observer</li>
<li>创建 Observable</li>
<li>Subscribe (订阅)</li>
</ul>
<h3 id="创建-Observer"><a href="#创建-Observer" class="headerlink" title="创建 Observer"></a>创建 Observer</h3><p>Observer 即观察者, 它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式:</p>
<pre><code class="java">Obeserver&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() {
     <span class="meta">@Override</span>
     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>{
          Log.d(tag, <span class="string">"Item:"</span> + s);
     }

     <span class="meta">@Override</span>
     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>{
          Log.d(tag, <span class="string">"Completed!"</span>);
     }

     <span class="meta">@Override</span>
     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>{
          Log.d(tag, <span class="string">"Error!"</span>);
     }
}
</code></pre>
<p>除了 Observer 接口之外, RxJava 还内置了一个实现 Observer 的抽象类: Subscriber。Subscriber 对 Observer 接口进行了一下拓展, 但他们的基本使用方式是完全一样的:</p>
<pre><code class="java">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() {
     <span class="meta">@Override</span>
     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>{
          Log.d(tag, <span class="string">"Item:"</span> + s);
     }

     <span class="meta">@Override</span>
     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>{
          Log.d(tag, <span class="string">"Completed!"</span>);
     }

     <span class="meta">@Override</span>
     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>{
          Log.d(tag, <span class="string">"Error!"</span>);
     }
}
</code></pre>
<p>不仅基本的使用方式一样, 实质上, 在 RxJava 的 Subscribe 过程中, Observer 也总是会被转换成一个 Subscriber 再使用。所以, 如果只是想使用基本功能, 选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点:</p>
<ul>
<li><p><strong>onStart():</strong> 这是 Subscriber 增加的方法。它会在 subscribe 刚开始, 而事件未发生之前被调用, 可以用于做一些准备工作, 例如数据的清零或重置。这是一个可选方法, 默认情况下它的实现为空。 需要注意的是, 如果对准备工作的线程有要求 (例如弹出一个显示进度的对话框，这必须在主线程执行), onStart() 就不适用了, 因为它总是在 subscribe 所发生的线程被调用, 而不能指定线程。 要在指定线程来做准备工作, 可以使用 doOnSubscribe() 方法。</p>
</li>
<li><p><strong>unsubscribe():</strong> 这是 Subscriber 所实现的另一个接口 Subscription 的方法, 用于取消订阅。在这个方法被调用后, Subscriber 将不再接受事件。一般在这个方法前，可以使用 isUnsubscribed() 先判断一下状态。unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause()、onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>
</li>
</ul>
<h3 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 Observable</h3><p>Observable 即被观察者, 它决定什么时候触发时间以及触发怎样的事件。RxJava 使用 create() 方法来创建一个 Observable, 并为它定义事件的触发规则:</p>
<pre><code class="java">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() {
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>{
        subscriber.onNext(<span class="string">"Hello"</span>);
        subscriber.onNext(<span class="string">"Hi"</span>);
        subscriber.onNext(<span class="string">"Aloha"</span>);
        subscriber.onCompleted();
    }
});
</code></pre>
<p>这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发 (对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted())。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<h3 id="RxJava-异步数据流处理"><a href="#RxJava-异步数据流处理" class="headerlink" title="RxJava 异步数据流处理"></a>RxJava 异步数据流处理</h3><ul>
<li>指定观察者生产数据所在的线程</li>
<li>指定订阅者接收数据所在的线程</li>
<li>强大的数据处理功能</li>
</ul>
<h3 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler (调度器)"></a>Scheduler (调度器)</h3><ul>
<li>默认情况下 RxJava 中生产者和订阅者都是在当前线程下运行</li>
<li>Scheduler 就是方便切换生产者和订阅者执行的线程</li>
<li>RxJava 默认提供了一些内置的 Scheduler, 方便针对不同的任务选择<ul>
<li>Schedulers.immediate() 默认线程</li>
<li>Schedulers.trampoline() 把我被观察者所生产数据的行为, 添加到一个队列里,依次执行</li>
<li>Schedulers.newThread() 在一个新开的线程里去操作, 每次都是 new 一个新的线程</li>
<li>Schedulers.computation() 适合 CPU 密集型的任务使用, 在底层 RxJava 根据 CPU 核数创建固定的线程池, 选择一个合适的线程</li>
<li>Schedulers.io() 适合 IO 密集型</li>
<li>AndroidSchedulers.mainThread() 在 Android 主线程执行相关任务</li>
</ul>
</li>
</ul>
<h3 id="数据处理-Operator"><a href="#数据处理-Operator" class="headerlink" title="数据处理 - Operator"></a>数据处理 - Operator</h3><ul>
<li>方便的对数据进行各种变换处理</li>
<li><p>内置丰富的 operators</p>
<ul>
<li>创建 create just</li>
<li>变换 map flatMap</li>
<li>过滤 filter first last</li>
<li>合并 merge zip</li>
<li>错误处理 catch</li>
<li>条件过滤 all skipUtil takeWhile</li>
<li>聚集函数 average reduce count</li>
</ul>
</li>
<li><p>自定义 operator</p>
<ul>
<li>lift</li>
</ul>
</li>
</ul>
<h3 id="Operator-需求演示"><a href="#Operator-需求演示" class="headerlink" title="Operator 需求演示"></a>Operator 需求演示</h3><ul>
<li>服务端返回一段字符串数组, 每个字符串都是数字</li>
<li>将数组每个元素转换成数字</li>
<li>过滤掉小于 1 的元素</li>
<li>去重</li>
<li>取前三个元素</li>
<li>累加求和</li>
</ul>
<h3 id="RxJava-在-Android-中的应用"><a href="#RxJava-在-Android-中的应用" class="headerlink" title="RxJava 在 Android 中的应用"></a>RxJava 在 Android 中的应用</h3><ul>
<li>Retrofit</li>
<li>RxAndroid</li>
<li><p>RxBinding</p>
<ul>
<li>使用 RxJava 对 Android UI 控件进行了封装</li>
</ul>
</li>
<li><p>RxPreferences</p>
<ul>
<li>使用 RxJava 封装 SharePreference</li>
</ul>
</li>
<li><p>sqlbrite</p>
</li>
<li>RxLifecycle<ul>
<li>根据 Activity 或者 Fragement 的生命周期, 在指定的时间中结束数据流</li>
</ul>
</li>
</ul>
<h2 id="RxJava-适用场景"><a href="#RxJava-适用场景" class="headerlink" title="RxJava 适用场景"></a>RxJava 适用场景</h2><ul>
<li>出现多层嵌套回调 (Callback hell)</li>
<li>复杂的数据处理</li>
<li>响应式 UI</li>
<li>复杂的线程切换</li>
</ul>
<h2 id="RxJava-的缺点"><a href="#RxJava-的缺点" class="headerlink" title="RxJava 的缺点"></a>RxJava 的缺点</h2><ul>
<li>库体积稍大 (900K)</li>
<li>入门不太容易</li>
<li>大量使用匿名对象, 容易造成内存泄露 (及时unSubscriber 或者使用 RxBinding)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2017年1月5日-下午3-07&quot;&gt;&lt;a href=&quot;#2017年1月5日-下午3-07&quot; class=&quot;headerlink&quot; title=&quot;2017年1月5日 下午3:07&quot;&gt;&lt;/a&gt;2017年1月5日 下午3:07&lt;/h3&gt;&lt;p&gt;未完成, 结合实践后继续完善
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 6.0 以后的权限申请</title>
    <link href="https://liurl21.github.io/2016/12/23/Android-6-0-%E4%BB%A5%E5%90%8E%E7%9A%84%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7/"/>
    <id>https://liurl21.github.io/2016/12/23/Android-6-0-以后的权限申请/</id>
    <published>2016-12-23T07:49:14.000Z</published>
    <updated>2016-12-23T07:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-权限分类"><a href="#Android-权限分类" class="headerlink" title="Android 权限分类"></a>Android 权限分类</h2><ul>
<li>Normal Permissions</li>
</ul>
<p>不涉及用户隐私的权限，不需要用户授权，在 AndroidManifest 文件中注册即可使用</p>
<ul>
<li>Dangerous Permission</li>
</ul>
<p>涉及用户隐私的权限，需要用户授权才可以使用</p>
<h2 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h2><ul>
<li>Normal Permissions</li>
<li>ACCESS_LOCATION_EXTRA_COMMANDS</li>
<li>ACCESS_NETWORK_STATE</li>
<li>ACCESS_NOTIFICATION_POLICY</li>
<li>ACCESS_WIFI_STATE</li>
<li>BLUETOOTH</li>
<li>BLUETOOTH_ADMIN</li>
<li>BROADCAST_STICKY</li>
<li>CHANGE_NETWORK_STATE</li>
<li>CHANGE_WIFI_MULTICAST_STATE</li>
<li>CHANGE_WIFI_STATE</li>
<li>DISABLE_KEYGUARD</li>
<li>EXPAND_STATUS_BAR</li>
<li>GET_PACKAGE_SIZE</li>
<li>INSTALL_SHORTCUT</li>
<li>INTERNET</li>
<li>KILL_BACKGROUND_PROCESSES</li>
<li>MODIFY_AUDIO_SETTINGS</li>
<li>NFC</li>
<li>READ_SYNC_SETTINGS</li>
<li>READ_SYNC_STATS</li>
<li>RECEIVE_BOOT_COMPLETED</li>
<li>REORDER_TASKS</li>
<li>REQUEST_INSTALL_PACKAGES</li>
<li>SET_ALARM</li>
<li>SET_TIME_ZONE</li>
<li>SET_WALLPAPER</li>
<li>SET_WALLPAPER_HINTS</li>
<li>TRANSMIT_IR</li>
<li>UNINSTALL_SHORTCUT</li>
<li>USE_FINGERPRINT</li>
<li>VIBRATE</li>
<li>WAKE_LOCK</li>
<li>WRITE_SYNC_SETTINGS</li>
</ul>
<blockquote>
<p>Dangerous Permissions 权限是按组分类的。如果用户授权了某一权限，则该权限所在的权限组的所有权限会被授权，该组的其他权限无需再申请即可使用。</p>
</blockquote>
<ul>
<li>Dangerous Permissions<ul>
<li>group:android.permission-group.CONTACTS</li>
</ul>
</li>
<li>WRITE_CONTACTS</li>
<li>GET_ACCOUNTS</li>
<li><p>READ_CONTACTS</p>
<ul>
<li>group:android.permission-group.PHONE</li>
</ul>
</li>
<li>READ_CALL_LOG</li>
<li>READ_PHONE_STATE</li>
<li>CALL_PHONE</li>
<li>WRITE_CALL_LOG</li>
<li>USE_SIP</li>
<li>PROCESS_OUTGOING_CALLS</li>
<li><p>ADD_VOICEMAIL</p>
<ul>
<li>group:android.permission-group.CALENDAR</li>
</ul>
</li>
<li>READ_CALENDAR</li>
<li><p>WRITE_CALENDAR</p>
<ul>
<li><p>group:android.permission-group.CAMERA</p>
<ul>
<li>CAMERA</li>
</ul>
</li>
<li><p>group:android.permission-group.SENSORS</p>
<ul>
<li>BODY_SENSORS</li>
</ul>
</li>
<li><p>group:android.permission-group.LOCATION</p>
</li>
</ul>
</li>
<li>ACCESS_FINE_LOCATION</li>
<li><p>ACCESS_COARSE_LOCATION</p>
<ul>
<li>group:android.permission-group.STORAGE</li>
</ul>
</li>
<li>READ_EXTERNAL_STORAGE</li>
<li><p>WRITE_EXTERNAL_STORAGE</p>
<ul>
<li>group:android.permission-group.MICROPHONE</li>
</ul>
</li>
<li><p>RECORD_AUDIO</p>
<ul>
<li>group:android.permission-group.SMS</li>
</ul>
</li>
<li>READ_SMS</li>
<li>RECEIVE_WAP_PUSH</li>
<li>RECEIVE_MMS</li>
<li>RECEIVE_SMS</li>
<li>SEND_SMS</li>
<li>READ_CELL_BROADCASTS</li>
</ul>
<h2 id="动态权限申请"><a href="#动态权限申请" class="headerlink" title="动态权限申请"></a>动态权限申请</h2><h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h3><p>注册权限前需要先检测应用是否已经拥有该权限。<br><code>ContextCompat.checkSelfPermission</code>，主要用于检测某个权限是否已经被授予，方法返回值为<code>PackageManager.PERMISSION_DENIED</code>或者<code>PackageManager.PERMISSION_GRANTED</code>。当返回<code>DENIED</code>就需要进行申请授权了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (ContextCompat.checkSelfPermission(Context,</div><div class="line">               Manifest.permission.权限名称)</div><div class="line">       != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">&#125;else&#123;</div><div class="line">   //</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="申请权限"><a href="#申请权限" class="headerlink" title="申请权限"></a>申请权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ActivityCompat.requestPermissions(Context,</div><div class="line">               new String[]&#123;Manifest.permission.权限名称&#125;,</div><div class="line">               CODE_PERMISSIONS_REQUEST);</div></pre></td></tr></table></figure>
<p>该方法是异步的，第一个参数是Context；第二个参数是需要申请的权限的字符串数组；第三个参数为requestCode，主要用于回调的时候检测权限是否授权。可以从方法名requestPermissions以及第二个参数看出，是支持一次性申请多个权限的，系统会通过对话框逐一询问用户是否授权。</p>
<h3 id="权限申请的回调"><a href="#权限申请的回调" class="headerlink" title="权限申请的回调"></a>权限申请的回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;</div><div class="line">    switch (requestCode) &#123;</div><div class="line">        case CODE_PERMISSIONS_REQUEST:</div><div class="line">            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line"></div><div class="line">                //权限获取成功</div><div class="line">                break;</div><div class="line"></div><div class="line">            &#125; else &#123;</div><div class="line"></div><div class="line">                //权限获取失败</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android-权限分类&quot;&gt;&lt;a href=&quot;#Android-权限分类&quot; class=&quot;headerlink&quot; title=&quot;Android 权限分类&quot;&gt;&lt;/a&gt;Android 权限分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Normal Permissions&lt;/li&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
